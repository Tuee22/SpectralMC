"""Strict, minimal CuPy subset for spectralmc (non‑generic ``ndarray`` to satisfy
``mypy --strict`` without forcing callers to write type parameters)."""

from __future__ import annotations

import numpy as np
from numpy.typing import NDArray
from typing import Tuple, TypeAlias, Union, overload

# Type aliases to avoid Any from numpy's ArrayLike/DTypeLike
_ArrayLike: TypeAlias = Union["ndarray", float, complex, int]
_DTypeLike: TypeAlias = Union["dtype", str]

# ---------------------------------------------------------------------------
# dtype – trivial wrapper so we can construct cp.dtype("float32") in code
# ---------------------------------------------------------------------------
class dtype:  # noqa: D101
    itemsize: int
    def __init__(self, obj: object, align: bool | None = ...) -> None: ...

float32: dtype
float64: dtype
complex64: dtype
complex128: dtype

# ---------------------------------------------------------------------------
# ndarray – we treat every CuPy array as ndarray without type parameters
# to avoid Any while keeping the interface simple for type checking.
# ---------------------------------------------------------------------------
class ndarray:
    # Properties ---------------------------------------------------------
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def dtype(self) -> dtype: ...

    # minimal arithmetic we rely on --------------------------------------
    def __mul__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __rmul__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __imul__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __truediv__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __rtruediv__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __itruediv__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __add__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __radd__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __iadd__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __sub__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __rsub__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...
    def __isub__(self, other: _ArrayLike | "ndarray") -> "ndarray": ...

    # indexing
    def __getitem__(self, key: object) -> "ndarray": ...

    # Array manipulation methods
    def squeeze(self, axis: int | None = ...) -> "ndarray": ...
    @overload
    def reshape(self, shape: Tuple[int, ...], /, order: str = ...) -> "ndarray": ...
    @overload
    def reshape(self, *shape: int, order: str = ...) -> "ndarray": ...
    def item(self) -> float: ...
    def mean(
        self, axis: int | Tuple[int, ...] | None = ..., keepdims: bool = ...
    ) -> "ndarray": ...

    # tiny helper needed by spectralmc -----------------------------------
    def toDlpack(self) -> object: ...

# ---------------------------------------------------------------------------
# Functional helpers referenced in code/tests
# ---------------------------------------------------------------------------

def zeros(
    shape: int | Tuple[int, ...],
    dtype: dtype | _DTypeLike | None = ...,
    order: str | None = ...,
) -> ndarray: ...
def linspace(
    start: float, stop: float, num: int = ..., *, dtype: dtype | _DTypeLike | None = ...
) -> ndarray: ...
def exp(x: _ArrayLike, /) -> ndarray: ...
def mean(
    a: _ArrayLike, *, axis: int | Tuple[int, ...] | None = ..., keepdims: bool = ...
) -> ndarray: ...
def maximum(a: _ArrayLike, b: _ArrayLike, /) -> ndarray: ...
def asarray(
    x: _ArrayLike | list["ndarray"], *, dtype: dtype | _DTypeLike | None = ...
) -> ndarray: ...
def expand_dims(a: _ArrayLike, axis: int) -> ndarray: ...
def allclose(
    a: _ArrayLike,
    b: _ArrayLike,
    *,
    rtol: float = ...,
    atol: float = ...,
    equal_nan: bool = ...,
) -> bool: ...

# ---------------------------------------------------------------------------
# Random namespace -----------------------------------------------------------
class _Generator:
    def standard_normal(
        self, shape: Tuple[int, ...], *, dtype: dtype | _DTypeLike | None = ...
    ) -> ndarray: ...

class _RandomNS:
    def default_rng(self, seed: int) -> _Generator: ...

random: _RandomNS

# ---------------------------------------------------------------------------
# FFT helper -----------------------------------------------------------------
class _FFTModule:
    def fft(self, a: _ArrayLike, axis: int = ..., n: int | None = ...) -> ndarray: ...

fft: _FFTModule

# ---------------------------------------------------------------------------
# CUDA sub‑module re-export + memory‑pool helpers expected at top level
# ---------------------------------------------------------------------------
from .cuda import _MemoryPool

def get_default_memory_pool() -> _MemoryPool: ...
def get_default_pinned_memory_pool() -> _MemoryPool: ...
